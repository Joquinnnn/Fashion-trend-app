# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jiUIhi6VmbY_6mYPjpGL7dzk5C5s63YX
"""

# app.py
import streamlit as st
import pandas as pd
import numpy as np
import plotly.graph_objects as go
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score

st.set_page_config(page_title="FashionTrendChecker", page_icon="ðŸ‘•", layout="wide")

st.title("ðŸ‘• FashionTrendChecker â€” MVP (Auto features, user chooses only Safety Stock)")

# ---------------------------
# Utility: smart numeric parsing
# ---------------------------
def clean_numeric_series(s):
    """Bersihkan string numeric seperti 'Rp13.720' atau '22.198,00' menjadi float/int."""
    # convert to str, remove Rp and spaces
    s = s.astype(str).str.replace(r'Rp|\s', '', regex=True)
    # Replace dot thousands and keep comma as decimal then convert
    # Some values may be like 22.198,00 or 13720
    # Normalization: if contains comma and dot, assume european format (dot thousand, comma decimal)
    def parse_val(v):
        v = str(v)
        if v == 'nan' or v.strip() == '':
            return np.nan
        # remove any non-number except . and ,
        # If both . and , present, assume . is thousand sep and , decimal
        if '.' in v and ',' in v:
            v = v.replace('.', '').replace(',', '.')
        else:
            # if only '.' present and no ',', could be thousand sep or decimal.
            # We assume '.' as decimal only if there are <=2 digits after dot; otherwise remove dots
            if '.' in v and ',' not in v:
                parts = v.split('.')
                if len(parts[-1]) == 3:  # likely thousand sep like 22.198
                    v = v.replace('.', '')
                # else keep as decimal (e.g., 76.25)
            # if only ',' present, assume comma is decimal
            if ',' in v and '.' not in v:
                v = v.replace(',', '.')
        # finally remove any leftover non-digit/decimal chars
        v = ''.join(ch for ch in v if ch.isdigit() or ch == '.')
        try:
            if v == '':
                return np.nan
            # return float or int depending on integeriness
            f = float(v)
            return f
        except:
            return np.nan

    return s.apply(parse_val)

# ---------------------------
# Load & prepare data
# ---------------------------
@st.cache_data
def load_and_prepare(path="data_sample.csv"):
    df = pd.read_csv(path, dtype=str)  # read as string for cleaning
    # standardize column names
    df.columns = [c.strip() for c in df.columns]

    # Expecting columns: MonthIndex, Month, Sales, TrendScore, USD_IDR
    # Clean numeric columns
    if 'Sales' in df.columns:
        df['Sales'] = clean_numeric_series(df['Sales']).astype(float)
    else:
        raise ValueError("CSV harus memiliki kolom 'Sales'.")

    if 'TrendScore' in df.columns:
        df['TrendScore'] = clean_numeric_series(df['TrendScore']).astype(float)
    else:
        raise ValueError("CSV harus memiliki kolom 'TrendScore'.")

    if 'USD_IDR' in df.columns:
        df['USD_IDR'] = clean_numeric_series(df['USD_IDR']).astype(float)
    else:
        raise ValueError("CSV harus memiliki kolom 'USD_IDR'.")

    # MonthIndex: if exists convert; otherwise create as sequential index
    if 'MonthIndex' in df.columns:
        df['MonthIndex'] = clean_numeric_series(df['MonthIndex']).astype(int)
    else:
        df = df.reset_index().rename(columns={'index': 'MonthIndex'})
        df['MonthIndex'] = df['MonthIndex'] + 1

    # Month: keep as string for plotting
    if 'Month' not in df.columns:
        # create pseudo month strings if missing
        df['Month'] = df['MonthIndex'].astype(str)

    # Sort by MonthIndex just in case
    df = df.sort_values('MonthIndex').reset_index(drop=True)
    return df

# try to load
try:
    df_history = load_and_prepare("data_sample.csv")
except Exception as e:
    st.error(f"Error saat membaca data_sample.csv: {e}")
    st.stop()

st.subheader("Preview data (cleaned)")
st.dataframe(df_history.head(10))

# ---------------------------
# Sidebar: only safety stock
# ---------------------------
st.sidebar.header("Pengaturan (MVP otomatis)")
safety_stock_percent = st.sidebar.slider("Safety Stock (%)", 0, 50, 20, help="Hanya ini yang perlu diinput user pada MVP.")
st.sidebar.caption("Sisa fitur (TrendScore & USD_IDR) diambil otomatis dari data historis terakhir.")

# ---------------------------
# Model training
# ---------------------------
features = ['MonthIndex', 'TrendScore', 'USD_IDR']
target = 'Sales'

# Train final model on 100% data for production prediction
X_full = df_history[features].values
y_full = df_history[target].values
model_full = LinearRegression()
model_full.fit(X_full, y_full)

# ---------------------------
# Auto-generate features for next period
# ---------------------------
last_month_index = int(df_history['MonthIndex'].max())
next_month_index = last_month_index + 1

# For TrendScore use average of last 3 months (fallback to last value)
trend_auto = df_history['TrendScore'].tail(3).mean()
if pd.isna(trend_auto):
    trend_auto = df_history['TrendScore'].iloc[-1]

# For USD_IDR use last known value (or average last 3)
usd_auto = df_history['USD_IDR'].iloc[-1]
if pd.isna(usd_auto):
    usd_auto = df_history['USD_IDR'].tail(3).mean()

input_features = pd.DataFrame({
    'MonthIndex': [next_month_index],
    'TrendScore': [trend_auto],
    'USD_IDR': [usd_auto]
})

# Predict next period demand
pred_next = model_full.predict(input_features[features])[0]
pred_next = max(0, int(round(pred_next)))

# Recommendation with safety buffer
safety_units = int(round(pred_next * (safety_stock_percent / 100.0)))
recommended_production = pred_next + safety_units

# ---------------------------
# Output - main dashboard
# ---------------------------
st.header("Hasil Prediksi & Rekomendasi Produksi (otomatis)")
col1, col2 = st.columns(2)
with col1:
    st.metric("Prediksi Permintaan (bulan selanjutnya)", f"{pred_next} unit")
    st.write(f"Input otomatis: TrendScore (rata-rata 3 bulan terakhir) = {trend_auto:.2f}, USD/IDR terakhir = {usd_auto:.0f}")
with col2:
    st.metric("Rekomendasi Produksi (dengan Safety Stock)", f"{recommended_production} unit", delta=f"+{safety_units} unit (safety={safety_stock_percent}%)")
    st.caption("Rekomendasi = Prediksi + Safety Stock")

# download recommendation
rec_df = pd.DataFrame({
    'NextMonthIndex': [next_month_index],
    'PredictedDemand': [pred_next],
    'SafetyPercent': [safety_stock_percent],
    'SafetyUnits': [safety_units],
    'RecommendedProduction': [recommended_production]
})
csv = rec_df.to_csv(index=False).encode('utf-8')
st.download_button("Download rekomendasi (CSV)", csv, file_name="recommendation.csv", mime="text/csv")

st.markdown("---")

# ---------------------------
# Visualization: Gauge (risk)
# ---------------------------
st.subheader("Visualisasi Risiko: Target Produksi vs Overproduction")
avg_hist = int(df_history['Sales'].mean())
max_gauge = max(avg_hist * 2.5, recommended_production * 1.5, pred_next * 2)

fig_gauge = go.Figure(go.Indicator(
    mode="gauge+number+delta",
    value=recommended_production,
    title={'text': "Rekomendasi Produksi (unit)"},
    delta={'reference': pred_next},
    gauge={
        'axis': {'range': [0, max_gauge]},
        'bar': {'color': "green"},
        'steps': [
            {'range': [0, pred_next * 0.9], 'color': "rgba(255,165,0,0.2)"},
            {'range': [pred_next * 0.9, pred_next], 'color': "rgba(144,238,144,0.5)"},
            {'range': [pred_next, recommended_production], 'color': "rgba(0,128,0,0.7)"},
            {'range': [recommended_production, max_gauge], 'color': "rgba(255,0,0,0.4)"}
        ],
        'threshold': {'line': {'color': "red", 'width': 4}, 'value': pred_next}
    }
))
fig_gauge.add_annotation(x=0.5, y=0.25, text=f"Prediksi: {pred_next} unit", showarrow=False)
st.plotly_chart(fig_gauge, use_container_width=True)

st.markdown("---")

# ---------------------------
# Historical chart: Sales & TrendScore
# ---------------------------
st.subheader("Grafik Historis: Penjualan vs TrendScore")
fig_hist = go.Figure()
fig_hist.add_trace(go.Scatter(
    x=df_history['Month'],
    y=df_history['Sales'],
    mode='lines+markers',
    name='Sales (unit)',
    line=dict(color='blue', width=3)
))
fig_hist.add_trace(go.Scatter(
    x=df_history['Month'],
    y=df_history['TrendScore'],
    mode='lines',
    name='TrendScore',
    yaxis='y2',
    line=dict(color='green', dash='dot')
))
fig_hist.update_layout(
    xaxis=dict(tickangle=-45),
    yaxis=dict(title='Sales (unit)', color='blue'),
    yaxis2=dict(title='TrendScore', overlaying='y', side='right', range=[0, 100]),
    title='Penjualan Historis vs TrendScore'
)
st.plotly_chart(fig_hist, use_container_width=True)

st.markdown("---")

# ---------------------------
# Evaluation: 80/20 train-test
# ---------------------------
st.header("Hasil Uji Coba & Evaluasi Model (80% train / 20% test)")
with st.expander("Klik untuk melihat detail evaluasi ðŸ”¬"):
    X = df_history[features]
    y = df_history[target]
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42, shuffle=False)

    # train eval model
    model_eval = LinearRegression()
    model_eval.fit(X_train, y_train)
    y_pred = model_eval.predict(X_test)

    mae = mean_absolute_error(y_test, y_pred)
    rmse = np.sqrt(mean_squared_error(y_test, y_pred))
    r2 = r2_score(y_test, y_pred)

    c1, c2, c3 = st.columns(3)
    c1.metric("RÂ²", f"{r2:.3f}")
    c2.metric("MAE", f"{mae:.2f} unit")
    c3.metric("RMSE", f"{rmse:.2f} unit")

    st.write("Interpretasi singkat:")
    if r2 >= 0.75:
        st.success(f"Model cukup baik (RÂ² = {r2:.2f}).")
    elif r2 >= 0.5:
        st.info(f"Model sedang (RÂ² = {r2:.2f}). Perlu data/fitur lebih banyak.")
    else:
        st.warning(f"Model lemah (RÂ² = {r2:.2f}). Pertimbangkan model/fitur lain.")

    st.markdown("**Contoh Actual vs Predicted (test set)**")
    res_df = pd.DataFrame({
        'Month': df_history.loc[X_test.index, 'Month'],
        'Actual': y_test.values,
        'Predicted': np.round(y_pred, 0).astype(int)
    }).reset_index(drop=True)
    st.dataframe(res_df, use_container_width=True)

    # plot actual vs pred
    fig_ev = go.Figure()
    fig_ev.add_trace(go.Scatter(x=res_df['Actual'], y=res_df['Predicted'], mode='markers', name='Data'))
    minv = min(res_df['Actual'].min(), res_df['Predicted'].min())
    maxv = max(res_df['Actual'].max(), res_df['Predicted'].max())
    fig_ev.add_trace(go.Scatter(x=[minv, maxv], y=[minv, maxv], mode='lines', name='Ideal', line=dict(color='red', dash='dash')))
    fig_ev.update_layout(title='Actual vs Predicted (Test Set)', xaxis_title='Actual (unit)', yaxis_title='Predicted (unit)')
    st.plotly_chart(fig_ev, use_container_width=True)

st.markdown("---")
st.info("Catatan: Pada MVP ini TrendScore dan USD_IDR diambil otomatis dari histori. Pada versi selanjutnya TrendScore akan di-scrape otomatis (TikTok/IG) dan USD_IDR via API BI.")